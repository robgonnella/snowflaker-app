#!/usr/bin/env python

import sys
import os
import csv
import re
from optparse import OptionParser

def die(msg):
    sys.exit(msg)

def validate_dir(dir):
    if (not os.path.isdir(dir)):
        die('Target must be a directory')
    return dir

def validate_csv(csv):
    if (not os.path.isfile(csv)):
        die('Snowflake map must be csv file')

    if (not csv.endswith('.csv')):
        die('Snowflake map must be csv file')
    return csv

def create_snowflake_map(path):
    with open(path, mode='r') as infile:
        reader = csv.reader(infile)
        snowflake_map = dict((rows[0],rows[1]) for rows in reader)
        return snowflake_map

def convert(target_dir, snowflake_map):
    for file in os.listdir(target_dir):
        file_parts = file.split('.')
        filename = file_parts[0]
        ext = file_parts[1]
        if filename in snowflake_map:
            new_name = snowflake_map[filename] + '.' + ext
            os.rename(file, new_name)
        elif filename in snowflake_map.values():
            print(('Skipping %s: Already a snowflake' % file))
        else:
            skip_msg = ('Skipping %s: Doesn\'t map to a snowflake' % file)
            print(skip_msg)
    print('Finished snowflakerizing files!')

def undo(target_dir, snowflake_map):
    for file in os.listdir(target_dir):
        file_parts = file.split('.')
        filename = file_parts[0]
        ext = file_parts[1]
        if filename in snowflake_map.values():
            for origin in snowflake_map:
                if snowflake_map[origin] == filename:
                    new_name = origin + '.' + ext
                    os.rename(file, new_name)
        else:
            print(('Skipping %s: Not a snowflake' % file))
    print('Files have been reset to their original names')

def qa_map(qa_file, snowflake_map):
    new_file = [];
    dirname = os.path.dirname(qa_file)
    outname = 'qa_mapping.csv'
    out_path = dirname + '/' + outname
    infile = open(qa_file)
    reader = csv.reader(infile)
    for row in reader:
        filename = row[0]
        if not filename:
            continue
        if not re.search(r'RAW_', filename):
            new_file.append(row)
            continue
        p_name = re.search(r'[Pp]\d{4}', filename)
        ext = filename.split('.')[1]
        file_id = filename.split('_')[6]
        candidate = p_name.group(0) + '_' + file_id
        print '\n'
        if (candidate in snowflake_map.values()):
            for origin in snowflake_map:
                if snowflake_map[origin] == candidate:
                    new_name = origin + '.' + ext
                    row.append(new_name)
                    new_file.append(row)
                    break
        else:
            new_file.append(row)
    with open(out_path, mode='w') as outfile:
        writer = csv.writer(outfile, lineterminator='\n')
        writer.writerows(new_file)
        print "\n"
        print('=========================')
        print('Mappings can be found at: %s' % out_path)
        print('=========================')
        print "\n"

def qa_wav(target_dir, snowflake_map):
    for file in os.listdir(target_dir):
        if re.search('.DS_Store', file):
            continue
        if not re.match('RAW', file):
            print(('Skipping %s: Not a QA file' % file))
            continue
        candidate = False
        file_session_id = file.split('_')[6]
        file_pname = re.search(r'[Pp]\d{4}', file)
        if file_pname:
            candidate = file_pname.group(0) + '_' + file_session_id
            print '\n'
            if (candidate in snowflake_map.values()):
                for origin in snowflake_map:
                    if snowflake_map[origin] == candidate:
                        new_name = origin + '_' + file
                        os.rename(file, new_name)
                        break
    print('QA files have been prepended with origin name')

def reverse_qa_wav(target_dir, snowflake_map):
    print "\n"
    for file in os.listdir(target_dir):
        if not re.match('\d{2,3}_', file):
            print '\n'
            print(
                ('Skipping file %s: Doesn\'t follow format' % file))
            continue
        parts = file.split('_')
        prefix = parts.pop(0)
        origin = '_'.join(parts)
        os.rename(file, origin)
    print('QA files restored to original names')



#################################################################
#################################################################
########################## RUN PROGRAM ##########################
#################################################################

def snowflakerize(csv_path, target_dir):
    os.chdir(target_dir)
    snowflake_map = create_snowflake_map(csv_path)
    convert(target_dir, snowflake_map)

def unsnowflakerize(csv_path, target_dir):
    os.chdir(target_dir)
    snowflake_map = create_snowflake_map(csv_path)
    undo(target_dir, snowflake_map)

def generate_qa_map(qa_file, csv_path):
    snowflake_map = create_snowflake_map(csv_path)
    qa_map(qa_file, snowflake_map)

def generate_qa_wav(csv_path, target_dir):
    os.chdir(target_dir)
    snowflake_map = create_snowflake_map(csv_path)
    qa_wav(target_dir, snowflake_map)

def undo_qa_wav(csv_path, target_dir):
    os.chdir(target_dir)
    snowflake_map = create_snowflake_map(csv_path)
    reverse_qa_wav(target_dir, snowflake_map)

def run():
    # logo = """

    # , ,    ,      ,    ,     ,     ,   ,      ,     ,     ,      ,      ,
    # ,       ,     ,    ,       ,   .____. ,   ,     ,      ,       ,      ,
    #  ,    ,   ,    ,     ,   ,   , |   :|         ,   , ,   ,   ,       ,
    #    ,        ,    ,     ,     __|====|__ ||||||  ,        ,      ,      ,
    #  ,   ,    ,   ,     ,    , *  / o  o \  ||||||,   ,  ,        ,    ,
    # ,   ,   ,         ,   ,     * | -=   |  \====/ ,       ,   ,    ,     ,
    #    ,  ,    ,   ,           , U==\__//__. \\//    ,  ,        ,    ,
    # ,   ,  ,    ,    ,    ,  ,   / \\==// \ \ ||  ,   ,      ,          ,
    #  ,  ,    ,    ,     ,      ,|    o ||  | \||   ,      ,     ,   ,     ,
    # ,      ,    ,    ,      ,   |    o ""  |\_|B),    ,  ,    ,       ,
    #   ,  ,    ,   ,     ,      , \__  --__/   ||  ,        ,      ,     ,
    # ,  ,   ,       ,     ,   ,  /          \  ||,   ,   ,      ,    ,    ,
    #  ,      ,   ,     ,        |            | ||      ,  ,   ,    ,   ,
    # ,    ,    ,   ,  ,    ,   ,|            | || ,  ,  ,   ,   ,     ,  ,
    #  ------_____---------____---\__ --_  __/__LJ__---------________-----___
    # """
    # print_color(logo, CYAN)
    parser = OptionParser(usage='Usage: %prog [option]')
    parser.add_option(
        '-s', '--snowflakify', action="store_true", dest='s',
        help='rename files according to snowflake map')
    parser.add_option(
        '-u', '--unsnowflakify', action="store_true", dest='u',
        help='reset files to origin name based on snowflake map')
    parser.add_option(
        '-m', '--gen-qa-map', action="store_true", dest='m',
        help='generate csv mapping from qa names to origin names')
    parser.add_option(
        '-q', '--gen-qa-wav', action="store_true", dest='q',
        help='rename qa wav files to include origin prefix')
    parser.add_option(
        '-z', '--undo-qa-wav', action="store_true", dest='z',
        help='remove prefix and restore QA file to original QA name')

    (options, args) = parser.parse_args()

    optcount = 0
    for opt, value in options.__dict__.items():
        if value:
            optcount += 1

    if optcount > 1:
        parser.error('Only one option at a time is supported\n')

    if len(args) != 2:
        parser.error('exactly 2 arguments required')

    validate_csv(args[0])
    if options.m:
        validate_csv(args[1])
    else:
        validate_dir(args[1])

    if options.s:
        snowflakerize(args[0], args[1])
    elif options.u:
        unsnowflakerize(args[0], args[1])
    elif options.m:
        generate_qa_map(args[0], args[1])
    elif options.q:
        generate_qa_wav(args[0], args[1])
    elif options.z:
        undo_qa_wav(args[0], args[1])
    else:
        parser.print_help()

run()

